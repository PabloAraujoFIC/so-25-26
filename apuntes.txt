APUNTES PARA DEFENDER SO

----- HEADERS -----

<stdio.h>:  printf, fprintf, perror, snprintf, putchar, getline, popen/pclose,
            fgets, fputs, fflush

<stdlib.h>: malloc, free, strtol, strtoll, strtoul, atoi, exit, bsearch

<string.h>: strcpy, strncpy, strncat, strcmp, strlen, memcpy, memset, strtok,
            strcspn, strdup

<errno.h>:  errno y constantes de error

<stdbool.h>: bool, true, false

<time.h>:   struct tm, time_t, strftime, localtime, localtime_r

<sys/types.h>: tipos POSIX (mode_t, off_t, pid_t, ssize_t)

<sys/stat.h>: stat, lstat, fstat, struct stat, macros S_*

<unistd.h>: read, write, close, lseek, unlink, rmdir, readlink, dup, getcwd,
            chdir, getpid, getppid, STDIN_FILENO/OUT/ERR

<ctype.h>:  tolower, isprint

<sys/utsname.h>: uname, struct utsname (info del kernel/host)

<sys/ipc.h>: key_t, IPC_CREAT/IPC_EXCL/IPC_STAT/IPC_RMID, IPC_PRIVATE

<sys/shm.h>: shmget, shmat, shmdt, shmctl, struct shmid_ds

<sys/mman.h>: mmap, munmap, PROT_*, MAP_*

<sys/wait.h>: waitpid, macros WIFEXITED/WEXITSTATUS

<stddef.h>: size_t, NULL, offsetof para estructuras

<fcntl.h>:  open, fcntl, flags de apertura O_*, F_GETFL, O_ACCMODE

<dirent.h>: opendir, readdir, closedir, struct dirent

<pwd.h>:    getpwuid, struct passwd

<grp.h>:    getgrgid, struct group

<limits.h>: PATH_MAX

<stdint.h> / <inttypes.h>: intmax_t y formato %jd

----- LLAMADAS AL SISTEMA -----

shmget(key_t key, size_t size, int flags)
    Crea/obtiene segmento System V (bloque de memoria compartida).
    Aquí: en shm_get (con IPC_CREAT|IPC_EXCL si tam>0).

shmat(int shmid, const void *addr, int shmflg)
    Adjunta el segmento y devuelve dirección.
    Aquí: en shm_get.

shmdt(const void *addr)
    Desadjunta un segmento ya mapeado.
    Aquí: en detach_shared_entry, destroy_shared_block.

shmctl(int shmid, int cmd, struct shmid_ds *buf)
    Consulta (IPC_STAT) o borra (IPC_RMID).
    Aquí: shm_get lee el tamaño real; delete_system_shared elimina del sistema.

mmap(void *addr, size_t length, int prot, int flags, int fd, off_t off)
    Mapea un fichero.
    Aquí: map_file (con MAP_PRIVATE, PROT_* según permisos).

munmap(void *addr, size_t length)
    Desmapea.
    Aquí: remove_mmap_entry, destroy_mmap_block.

open(const char *path, int flags, mode_t mode)
    Abrir fichero (lectura/escritura/creación).
    Aquí: map_file, cmd_writefile.

close(int fd)
    Cerrar descriptor.
    Aquí: varias funciones tras open.

read(int fd, void *buf, size_t count)
    Copia count bytes desde un fd del kernel a memoria de tu proceso buf.
    Aquí: cmd_read, read_file_chunk (lee desde fichero a memoria del proceso).

write(int fd, const void *buf, size_t count)
    Escribe count bytes de buf en el fichero con descriptor fd.
    Aquí: cmd_write, cmd_writefile.

stat(const char *path, struct stat *st)
    Obtener tamaño/estado del fichero.
    Aquí: map_file, read_file_chunk.

getpid(void)
    PID del proceso para pmap/vmmap.
    (vía popen/pclose) se invoca programa externo pmap (Linux) o vmmap (macOS)
    — no es syscall, pero ejecuta proceso hijo y lee su salida.
 
getppid(void)
    Devuelve el PID del proceso padre (cmd_getpid -p).

uname(struct utsname *buf)
    Recupera nombre de nodo, kernel y arquitectura del sistema.
    Aquí: cmd_infosys.

chdir(const char *path)
    Cambia el directorio actual del proceso.
    Aquí: cmd_cd.

getcwd(char *buf, size_t size)
    Devuelve en buf la ruta absoluta del directorio actual.
    Aquí: cmd_cwd/cd cuando imprime el working dir.

dup(int oldfd)
    Duplica un descriptor y comparte offset/flags con el original.
    Aquí: cmd_dup y al registrar stdin/stdout/stderr en LF.

lseek(int fd, off_t offset, int whence)
    Reposiciona el puntero del descriptor; devuelve la nueva posición.
    Aquí: cmd_lseek y cmd_listOpen (consulta SEEK_CUR).

mkdir(const char *path, mode_t mode)
    Crea un directorio con los permisos solicitados.
    Aquí: cmd_create (sin -f).

rmdir(const char *path)
    Borra un directorio vacío.
    Aquí: cmd_erase y cmd_delrec.

unlink(const char *path)
    Elimina la entrada de directorio de un fichero regular.
    Aquí: cmd_erase y delrec_path.

readlink(const char *path, char *buf, size_t buflen)
    Lee el destino de un enlace simbólico sin seguirlo.
    Aquí: cmd_dir cuando showlink=true.

lstat(const char *path, struct stat *st)
    Igual que stat pero sin seguir enlaces simbólicos.
    Aquí: cmd_dir, cmd_erase y cmd_delrec.

----- ESTRUCTURAS -----

struct shmid_ds {
    struct ipc_perm shm_perm;   // permisos y dueño
    size_t          shm_segsz;  // tamaño del segmento (bytes)
    time_t          shm_atime;  // última vez que se adjuntó (shmat)
    time_t          shm_dtime;  // última vez que se desadjuntó (shmdt)
    time_t          shm_ctime;  // última modificación de los metadatos
    pid_t           shm_cpid;   // PID del creador
    pid_t           shm_lpid;   // PID del último proceso que lo usó
    shmatt_t        shm_nattch; // número de procesos actualmente adjuntos
};

struct ipc_perm {
    key_t  __key;   // clave System V usada en shmget()
    uid_t  uid;     // propietario
    gid_t  gid;     // grupo propietario
    uid_t  cuid;    // creador
    gid_t  cgid;    // grupo creador
    mode_t mode;    // bits de permisos (como en ficheros: 0666, 0644, etc.)
    unsigned short seq;  // número de secuencia interno
};

struct stat {
    dev_t     st_dev;     // ID del dispositivo que contiene el archivo
    ino_t     st_ino;     // Número de inodo
    mode_t    st_mode;    // Tipo de archivo y permisos
    nlink_t   st_nlink;   // Número de enlaces duros
    uid_t     st_uid;     // ID del usuario propietario
    gid_t     st_gid;     // ID del grupo propietario
    dev_t     st_rdev;    // Tipo de dispositivo (para nodos especiales)
    off_t     st_size;    // Tamaño total del archivo en bytes
    blksize_t st_blksize; // Tamaño de bloque óptimo para I/O
    blkcnt_t  st_blocks;  // Número de bloques de disco asignados

    // Marcas de tiempo:
    struct timespec st_atim; // Último acceso (atime)
    struct timespec st_mtim; // Última modificación (mtime)
    struct timespec st_ctim; // Último cambio de metadatos (ctime)
};

struct timespec {
    time_t tv_sec;   // segundos desde Epoch
    long   tv_nsec;  // nanosegundos (0..999,999,999)
};

struct dirent {
    ino_t          d_ino;       // Inodo de la entrada
    off_t          d_off;       // Offset al siguiente dirent (no siempre útil)
    unsigned short d_reclen;    // Longitud de esta entrada
    unsigned char  d_type;      // Tipo (DT_REG, DT_DIR, DT_LNK, ...)
    char           d_name[];    // Nombre NUL-terminado (tamaño variable)
};

struct passwd {
    char  *pw_name;   // nombre login (ej. "Pablo")
    char  *pw_passwd; // hash de password (a menudo "x" -> /etc/shadow)
    uid_t  pw_uid;    // UID
    gid_t  pw_gid;    // GID primario
    char  *pw_gecos;  // info descriptiva (nombre real, etc.)
    char  *pw_dir;    // directorio home (ej. "/home/Pablo")
    char  *pw_shell;  // shell de login (ej. "/bin/bash")
};

struct group {
    char   *gr_name;  // nombre del grupo
    char   *gr_passwd;// (normalmente "x")
    gid_t   gr_gid;   // GID
    char  **gr_mem;   // lista de miembros (array de char* terminado en NULL)
};

struct tm {
    int tm_sec;    // 0..60 (leap second)
    int tm_min;    // 0..59
    int tm_hour;   // 0..23
    int tm_mday;   // 1..31 (día del mes)
    int tm_mon;    // 0..11  (0=enero)
    int tm_year;   // años desde 1900 (p.ej. 125 -> 2025)
    int tm_wday;   // 0..6   (0=domingo)
    int tm_yday;   // 0..365 (día del año)
    int tm_isdst;  // >0 DST; =0 no DST; <0 desconocido

    // Extensiones GNU/BSD (no POSIX puro):
    long        tm_gmtoff;  // offset a UTC en segundos
    const char *tm_zone;    // nombre de zona horaria
};

struct utsname {
    char sysname[_UTSNAME_SYSNAME_LENGTH];
    char nodename[_UTSNAME_NODENAME_LENGTH];
    char release[_UTSNAME_RELEASE_LENGTH];
    char version[_UTSNAME_VERSION_LENGTH];
    char machine[_UTSNAME_MACHINE_LENGTH];
#ifdef _GNU_SOURCE
    char domainname[_UTSNAME_DOMAIN_LENGTH];
#endif
};

typedef struct Node {
    int id;
    void *data;
    struct Node *next;
    struct Node *prev;
} Node;

typedef struct { Node *head; } List;

typedef struct Shell{
    List *LH;   // historial
    List *LF;   // ficheros abiertos
    int   command_count;
    bool  end;
} Shell;

typedef int (*command_fn)(int argc, char *argv[], struct Shell *sh);

typedef struct {
    const char *name;
    command_fn  func;
    const char *help;
} command_entry;

typedef struct tItemH{
    int   id;     // número de entrada en historial
    char *name;   // comando completo (strdup)
} tItemH;

typedef struct tItemF{
    int  fileDescriptor; // fd abierto
    char filename[MAX];  // ruta guardada
    int  mode;           // flags O_* usados al abrir
} tItemF;

typedef enum { DIR_REC_NOREC = 0, DIR_REC_RECA, DIR_REC_RECB } dir_rec_t;

typedef struct {
    bool      longfmt;    // salida corta/larga
    bool      showlink;   // mostrar destino de symlinks
    bool      showhid;    // incluir ocultos ('.')
    dir_rec_t rec;        // estrategia: norec|reca|recb
} DirParams;

typedef struct {
    void  *addr;
    size_t size;
} MallocBlock;

typedef struct {
    key_t   key;
    size_t  size;
    void   *addr;
    int     shmid;
} SharedBlock;

typedef struct {
    char    path[PATH_MAX];
    size_t  size;
    void   *addr;
    int     fd;
    int     protection;
    int     flags;
} MmapBlock;

struct SEN {
    char *nombre;
    int senal;
};

enum Status {FINISHED, STOPPED, SIGNALED, ACTIVE};

typedef struct {
    pid_t pid;                      // id del proceso
    time_t launch_time;             // Momento de inicio del proceso
    enum Status status;             // FINISHED, STOPPED, SIGNALED, ACTIVE
    int exit_status;                // Válido cuando FINISHED
    int signal_number;              // Válido cuando STOPPED/SIGNALED
    char command_line[MAX_COMMAND]; // Línea original de comando
    int priority;                   // Prioridad
} ProcessInfo;

typedef struct {
    char *argv[MAX_TR];
    int argc;
    bool background;
    bool has_priority;
    int priority;
} ExecSpec;



----- FLAGS Y MACROS -----

Modo de acceso:
O_RDONLY            Solo lectura
O_WRONLY            Solo escritura
O_RDWR              Lectura/escritura

Modificadores:
O_CREAT             Crea si no existe (requiere modo 0666 en 3er parámetro)
O_EXCL              Con O_CREAT, falla si ya existe (creación exclusiva)
O_TRUNC             Trunca a tamaño 0 si existe (y tienes permiso de escritura)
O_APPEND            Escribe siempre al final (mueve offset al EOF antes de cada
                    write)

fcntl:
F_GETFL             Devuelve los flags del descriptor
flags & O_ACCMODE   Extrae el modo de acceso (ro/wo/rw).

Tipos de archivo:
__S_IFMT            Máscara de tipo
__S_IFSOCK          Socket
__S_IFLNK           Enlace simbólico
__S_IFREG           Archivo Regular
__S_IFBLK           Dispositivo de bloques
__S_IFDIR           Directorio
__S_IFCHR           Dispositivo de caracteres
__S_IFIFO           FIFO/pipe

S_ISSOCK(st_mode)	Socket
S_ISLNK(st_mode)	Enlace simbólico
S_ISREG(st_mode)	Archivo regular
S_ISBLK(st_mode)	Dispositivo de bloques
S_ISDIR(st_mode)	Directorio
S_ISCHR(st_mode)	Dispositivo de caracteres
S_ISFIFO(st_mode)	FIFO / pipe

Permisos:
| Propietario    | Grupo          | Otros          |
| -------------- | -------------- | -------------- |
| S_IRUSR (0400) | S_IRGRP (0040) | S_IROTH (0004) |
| S_IWUSR (0200) | S_IWGRP (0020) | S_IWOTH (0002) |
| S_IXUSR (0100) | S_IXGRP (0010) | S_IXOTH (0001) |

Desplazamiento (lseek):
SEEK_SET            Desde inicio
SEEK_CUR            Desde posición actual
SEEK_END            Desde final

Descriptores estándar:
STDIN_FILENO  (0)   Entrada estándar (se registra en LF como "stdin").
STDOUT_FILENO (1)   Salida estándar ("stdout").
STDERR_FILENO (2)   Error estándar ("stderr"); no se cierra automáticamente.

Flags System V (sys/ipc.h / sys/shm.h):
IPC_CREAT           Crea el segmento si no existe.
IPC_EXCL            Con IPC_CREAT obliga a que falle si ya existe.
IPC_STAT            shmctl obtiene metadatos (struct shmid_ds).
IPC_RMID            shmctl elimina el segmento del sistema.
IPC_PRIVATE         Clave reservada para crear segmentos no compartidos.

Memoria mapeada (sys/mman.h):
PROT_READ/WRITE/EXEC    Permisos por página (lectura, escritura, ejecución).
MAP_PRIVATE             Mapeo privado (cambios no escriben en fichero).
MAP_FAILED              Valor especial devuelto por mmap en error.

Recorrido de directorios:
DIR_REC_NOREC       No lista recursivamente.
DIR_REC_RECA        Lista directorio antes de bajar a subdirectorios.
DIR_REC_RECB        Lista hijo primero y directorio al final.

Permisos extendidos:
S_IRWXU/S_IRWXG/S_IRWXO    Combos rwx completos para usuario/grupo/otros.
S_ISUID                    Bit setuid (ejecutables heredan UID del dueño).
S_ISGID                    Bit setgid (hereda GID o marca directorios).
S_ISVTX (__S_ISVTX)        "Sticky bit" (solo dueño puede borrar en dir
                           tipo /tmp).

Otras macros:
_POSIX_C_SOURCE 200809L    Activa funciones POSIX como getline o popen.
WIFEXITED(status)          Comprueba si pmap/vmmap terminó normalmente (wait.h).
WEXITSTATUS(status)        Código de salida del proceso hijo.
EINTR                      Error transitorio al escribir/leer; se reintenta
                           (write_all).

Tamaños y límites del programa:
MAX_COMMAND (1024)         Buffer para la línea leída.
MAX_TR (100)               Número máximo de tokens que se trocean.
MAX_FILES (1024)           Límite de ficheros trackeados (p0.h).
MAX (1024)                 Tamaño del nombre guardado en tItemF.
TAMANO (1024)              Bytes reservados en la recursión (stack/static).
PATH_MAX (4096)            Rutas completas para dir/readlink/mmap (fallback en
                           memoria.h).

----- FUNCIONES DE LIBRERÍAS -----
Ficheros:
open(path, flags[, mode])   Abre/crea. Devuelve fd o -1.
close(fd)                   Cierra. Por seguridad no se cierran fd 0, 1 y 2.
dup(fd)                     Duplica descriptor, con misma posición/flags.
lseek(fd, off, whence)      Mueve el offset y devuelve la nueva posición.
fcntl(fd, F_GETFL)          Lee flags del fd (O_*).

Directorios:
opendir(path) / readdir(DIR*) / closedir(DIR*)  Iteración de entradas.
mkdir(path, mode)   Crea directorio.
rmdir(path)         Borra directorio vacío.
getcwd(buf, size)   Copia en buf el directorio actual (cmd_cwd/cd).
chdir(path)         Cambia el directorio de trabajo del proceso (cmd_cd).

Enlaces y borrado:
lstat(path, &sb)    Stat sin seguir symlinks (clave para listar tipo ls -l).
readlink(path, buf, buflen) Lee destino de symlink.
unlink(path)        Borra nombre de archivo (enlace) del directorio.

I/O crudo:
read(fd, buf, count)    Lee hasta count bytes; devuelve ssize_t (>=0 o -1).
write(fd, buf, count)   Escribe hasta count o menos; devuelve ssize_t.
write_all               Reintenta hasta completar (EINTR), patrón correcto.

Procesos externos y stdio:
popen(cmd,"r")          Lanza pmap/vmmap y devuelve FILE* para leer su salida.
pclose(FILE*)           Espera al proceso lanzado por popen y da su status.
fgets(buf, n, FILE*)    Lee líneas del pipe antes de imprimirlas tal cual.
fputs(str, stdout)      Reenvía cada línea recibida.
fflush(stdout)          Vacía el buffer tras limpiar la pantalla (cmd_clear).

Usuarios y grupos:
getpwuid(uid)           Struct passwd* (puede ser NULL → “unknown”).
getgrgid(gid)           Struct group*.

Tiempo:
time(NULL)                  Epoch actual (segundos desde 1970) para cmd_date.
localtime(&time_t)          Convierte a hora local (versión no thread-safe).
localtime_r(&time_t, &tm)   Seguro para hilos; strftime para formatear.

Conversión/parsing y utilidades:
strtol, strtoll, strtoul, atoi   Parseo de enteros (fd, tamaños, claves).
getline(&buf, &len, stdin)       Lee la línea completa del usuario (readCommand)
strtok(str, " \n\t")             Trocea la línea en argumentos (chopString).
strcspn(str, "\n")               Encuentra el '\n' para eliminarlo.
strdup(str)                      Copia el comando antes de meterlo en historial.
sscanf(str, "%p", &ptr)          Convierte cadenas a punteros (parse_pointer).
strcmp, strlen, strncpy, strncat, memcpy, memset.
snprintf                         Construcción segura de rutas (dir/dirrec).
bsearch(key, tabla, n, sizeof, cmp)  Encuentra el comando en la tabla ordenada.
perror, fprintf(stderr, ...)     Reportar errores (errno).
tolower/isprint                  Dan representación legible en memdump.

----- OTROS -----

uintptr_t x;   // entero sin signo capaz de almacenar una dirección
intptr_t  y;   // entero con signo capaz de almacenar una dirección
key_t     k;   // identificador System V que usa shared/mmap.
pid_t     p;   // tipo devuelto por getpid/getppid.
ssize_t   n;   // size_t con signo que devuelven read/write.
dir_rec_t rec; // enum para controlar el comportamiento de 'dir'.
List *LF/LH;   // listas doblemente enlazadas (ficheros abiertos, historial).
pmap / vmmap   // programas externos que se ejecutan con popen en cmd_mem -pmap.

Procesos (procesos.c / procesos.h):
_GNU_SOURCE, MAXVAR, MAX_COMMAND.

Funciones públicas:
procesos_init, procesos_shutdown, procesos_refresh
VaciarListaProcesos
cmd_fork, cmd_uid, cmd_exec, cmd_jobs, cmd_deljobs
execute_external_command

Helpers internos:
ensure_process_list, destroy_process_info, record_status_from_wait
refresh_background_processes, create_process_info, add_background_process
parse_priority_token, parse_progspec_tokens, build_command_line,
apply_priority_if_needed status_to_string, format_launch_time, print_process,
remove_jobs_by_status

Llamadas de sistema / libc:
fork, execvp, waitpid, setpriority/getpriority (PRIO_PROCESS)
setuid, seteuid, getuid, geteuid, getgid, getegid, initgroups, setgid, getpwnam

Macros de señales:
SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGIOT, SIGBUS, SIGFPE,
SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,
SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,
SIGPROF, SIGWINCH, SIGIO, SIGSYS (+ condicionales SIGPOLL, SIGPWR, SIGEMT,
SIGINFO, SIGSTKFLT, SIGCLD, SIGLOST, SIGCANCEL, SIGTHAW, SIGFREEZE, SIGLWP,
SIGWAITING).

Macros de wait:
WNOHANG, WUNTRACED, WCONTINUED, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG,
WIFCONTINUED.
